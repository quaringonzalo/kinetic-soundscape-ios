//
//  BehaviorBase.swift
//  Soundscape
//
//  Copyright (c) Microsoft Corporation.
//  Licensed under the MIT License.
//

import CoreLocation

class BehaviorBase: Behavior {
    let id = UUID()
    
    lazy var description: String = {
        return NSStringFromClass(type(of: self)).components(separatedBy: ".").last!
    }()
    
    /// Delegate responsible for handling the callouts generated by this behavior
    weak var delegate: BehaviorDelegate?
    
    /// Indicates if the behavior is currently active
    private(set) var isActive: Bool = false
    
    /// Indicates if the behavior is currently being deactivated
    private(set) var isDeactivating: Bool = false
    
    private(set) var isInSleepMode: Bool = false
    
    /// Behaviors should keep track of the latest user location update events since generators
    /// may need that information to create callouts
    var userLocation: CLLocation?
    
    /// The current verbosity level of the behavior. This property is not currently being
    /// utilized but will be when openscape supports mutiple verbosity levels.
    var verbosity: Verbosity = .normal
    
    /// Set of automatic generator types in the parent behavior chain that should be blocked when
    /// this generator is active
    private(set) var blockedAutoGenerators: [AutomaticGenerator.Type]
    
    /// Set of manual generator types in the parent behavior chain that should be blocked when
    /// this generator is active
    private(set) var blockedManualGenerators: [ManualGenerator.Type]
    
    /// Generators that are manually invoked by user interaction events and always interrupt
    var manualGenerators: [ManualGenerator] = []
    
    /// Generators that are invoked by state change events and generate normal callouts that
    /// should be queued behind any callouts currently playing
    var autoGenerators: [AutomaticGenerator] = []
    
    /// Reference to the behavior this behavior is layered on top of (e.g. the default Soundscape
    /// behavior). Custom behaviors must have access to their parent behaviors so they can mediate
    /// the degree to which the parent behaviors still function when they are the active behavior.
    /// Important: This must be a strong reference.
    private(set) var parent: Behavior?
    
    /// Initializes a behavior by setting the parent generator types that this behavior will not delegate events to.
    ///
    /// - Parameters:
    ///   - blockedAutoGenerators: Auto generator types in the parent behavior that are NOT allowed to handle events that this behavior receives
    ///   - blockedManualGenerators: Manual generator types in the parent behavior that are NOT allowed to handle events that this behavior receives but doesn't handle
    init(blockedAutoGenerators: [AutomaticGenerator.Type] = [], blockedManualGenerators: [ManualGenerator.Type] = []) {
        self.blockedAutoGenerators = blockedAutoGenerators
        self.blockedManualGenerators = blockedManualGenerators
    }
    
    /// Called by the `EventProcessor` when this behavior is activated. Adds this behavior
    /// to the top of the behavior stack.
    ///
    /// - Parameter parent: The parent behavior
    func activate(with parent: Behavior?) {
        guard !isActive else {
            GDLogError(.eventProcessor, "Attempted to activate a behavior that has already been activated!")
            return
        }
        
        self.parent = parent
        isActive = true
        GDATelemetry.track("\(description.lowercased()).activate")
    }
    
    func willDeactivate() {
        // Classes that inherit from BehaviorBase can override this method and use it for cleaning up
        // state before the behavior is deactivated.
        isDeactivating = true
    }
    
    /// Called by the `EventProcessor` when this behavior is deactivated. Removes this
    /// behavior from the top of the behavior stack.
    ///
    /// - Returns: The parent behavior if one was set
    func deactivate() -> Behavior? {
        let tempParent = parent
        parent = nil
        
        isActive = false
        GDATelemetry.track("\(description.lowercased()).deactivate")
        
        return tempParent
    }
    
    func sleep() {
        isInSleepMode = true
    }
    
    func wake() {
        isInSleepMode = false
    }
    
    func addBlocked(auto gen: AutomaticGenerator.Type) {
        guard !blockedAutoGenerators.contains(where: { $0 == gen }) else {
            return
        }
        
        blockedAutoGenerators.append(gen)
    }
    
    func removeBlocked(auto gen: AutomaticGenerator.Type) {
        guard let index = blockedAutoGenerators.firstIndex(where: { $0 == gen }) else {
            return
        }
        
        blockedAutoGenerators.remove(at: index)
    }
    
    func addBlocked(manual gen: ManualGenerator.Type) {
        guard !blockedManualGenerators.contains(where: { $0 == gen }) else {
            return
        }
        
        blockedManualGenerators.append(gen)
    }
    
    func removeBlocked(manual gen: ManualGenerator.Type) {
        guard let index = blockedManualGenerators.firstIndex(where: { $0 == gen }) else {
            return
        }
        
        blockedManualGenerators.remove(at: index)
    }
    
    /// Method called when a new event is received by the `EventProcessor`. For events that
    /// implement `UserInitiatedEvent`, the behavior's manual generators will be checked to
    /// see if any respond to the event, and if none do, then the event will be passed to the
    /// behavior's parent. Similarly, events that implement `StateChangeEvent` will be checked
    /// to see if any of the behavior's automatic generators respond to the event, before passing
    /// the event to the behavior's parent. In either case, the event is not passed to the parent
    /// behavior if even a single generator in the behavior responds to the event.
    ///
    /// - Parameter event: An event object
    func handleEvent(_ event: Event, blockedAuto: [AutomaticGenerator.Type] = [], blockedManual: [ManualGenerator.Type] = [], completion: @escaping ([HandledEventAction]?) -> Void) {
        // Ignore events if we are in sleep mode
        guard !isInSleepMode else {
            completion(nil)
            return
        }
        
        if let locEvent = event as? LocationUpdatedEvent {
            userLocation = locEvent.location
        }
        
        switch event {
        case let event as UserInitiatedEvent:
            handleUserInteraction(event: event, blocked: blockedManual, completion: completion)
            
        case let event as StateChangedEvent:
            handleStateChange(event: event, blocked: blockedAuto, completion: completion)
            
        default:
            GDLogEventProcessorError("Unable to process event that implements neither UserInitiatedEvent nor StateChangeEvent")
            completion(nil)
        }
    }
    
    /// Attempts to generate callouts from the manual generators using this event. Note that user initiated
    /// callouts always interrupt the current callout (if it exists), clear the queue, and the enqueue their
    /// new callouts.
    ///
    /// - Parameter event: An event object
    /// - Returns: False if no generators respond to this event, true otherwise.
    private func handleUserInteraction(event: UserInitiatedEvent, blocked: [ManualGenerator.Type] = [], completion: @escaping ([HandledEventAction]?) -> Void) {
        let generators = manualGenerators.filter { gen in
            let isBlocked = event.blockable && blocked.contains { $0 == type(of: gen) }
            return !isBlocked && gen.respondsTo(event)
        }
        
        guard let generator = generators.first else {
            // None of the manual generators respond to this type of event, pass it onto the parent
            // behavior's manual generators if a parent behavior exists.
            parent?.handleEvent(event, blockedAuto: blockedAutoGenerators, blockedManual: blockedManualGenerators, completion: completion)
            return
        }
        
        guard let action = generator.handle(event: event, verbosity: verbosity) else {
            completion(nil)
            return
        }
        
        completion([action])
    }
    
    /// Checks if any auto generators can handle the event and if so, attempts to generate callouts
    /// for the event.
    ///
    /// - Parameter event: An event object
    private func handleStateChange(event: StateChangedEvent, blocked: [AutomaticGenerator.Type] = [], completion: @escaping ([HandledEventAction]?) -> Void) {
        let actions: [HandledEventAction]
        let generators = autoGenerators.filter { gen in
            let isBlocked = event.blockable && blocked.contains { $0 == type(of: gen) }
            return !isBlocked && gen.respondsTo(event)
        }
        
        if event.distribution == .broadcast {
            actions = generators.compactMap({ generator in
                generator.handle(event: event, verbosity: verbosity)
            })
            
            if let parent = parent {
                parent.handleEvent(event, blockedAuto: blockedAutoGenerators, blockedManual: blockedManualGenerators) { parentActions in
                    guard let parentActions = parentActions else {
                        completion(actions)
                        return
                    }
                    
                    completion(actions + parentActions)
                }
                
                return
            }
            
            completion(actions)
            return
        }
        
        // The event isn't being distributed to all generators, so just find the first generator that will handle it
        if let action = generators.first.flatMap({ $0.handle(event: event, verbosity: verbosity) }) {
            actions = [action]
        } else {
            actions = []
        }
        
        guard !actions.isEmpty else {
            // This behavior didn't generate any callouts, so check if the parent behavior can if this is a broadcast event
            // of there were no other generators that consumed the event
            if generators.count == 0 {
                parent?.handleEvent(event, blockedAuto: blockedAutoGenerators, blockedManual: blockedManualGenerators, completion: completion)
                return
            }
            
            completion(nil)
            return
        }
        
        completion(actions)
    }
}
